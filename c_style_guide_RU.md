# Введение | Introduction
Этот стандарт стиля предназначен для стандартизации кода, создаваемого различными командами в соответствии с рекомендациями, используемыми в Google и в общем разработческом сообществе. Код, оформленный в едином формате, обеспечивает большую читаемость.
При расширении существующего проекта, который еще не следует этому руководству, стремитесь к последовательности. Говорите на местном диалекте. Добивайтесь единства подхода и облегчайте задачу чтения вашего кода другому человеку (это можете быть Вы сами в будущем).
Этот стандарт не является книгой, которой следует пользоваться во время проверки кода других. Вместо этого, если возникает вопрос о том, как что-то должно быть отформатировано, этот стандарт будет объективной ссылкой на то, как должен выглядеть код. Большая часть текста здесь взята из Руководства по стилю Google для C++. Оно было адаптировано под наши потребности и предпочтения. Этот стандарт не является священным каноном. Если есть сомнения, делайте то, что имеет больше смысла для вашего конкретного проекта или использования.

Используйте здравый смысл и **БУДЬТЕ ПОСЛЕДОВАТЕЛЬНЫ**.
Если вы редактируете код, посмотрите на код вокруг и определите его стиль. Если у соседних комментариев есть рамки из звездочек, сделайте такие же рамки и для своих комментариев.
Стандарты стиля существуют для того, чтобы у нас был общий язык программирования, чтобы люди могли сосредоточиться на содержании, а не на форме. Мы предоставляем общие правила стиля, чтобы у всех был одинаковый язык. Однако важен и локальный стиль. Если ваш код отличается от окружающего, это может сбить с толку читателей. Старайтесь этого избегать.

# Файлы заголовков | Header Files
В общем случае, каждый файл .c должен иметь связанный файл .h. Существуют некоторые общие исключения, такие как модульные тесты и маленькие файлы .c, содержащие только функцию main().
Правильное использование файлов заголовков может существенно повлиять на читаемость, размер и производительность вашего кода.
Следующие правила помогут вам избежать различных проблем при использовании файлов заголовков.

## Само-содержащие заголовочные файлы | Self-contained Headers
Заголовочные файлы должны быть само-содержащими и иметь расширение .h. Файлы, предназначенные для текстового включения, но не являющиеся заголовками, должны иметь расширение .inc.
Все заголовочные файлы должны быть само-содержащими. Иными словами, пользователи и инструменты рефакторинга не должны придерживаться специальных условий для включения заголовка. В частности, заголовок должен иметь защиту от множественного включения и должен включать все другие заголовки, которые ему нужны.
Существуют редкие случаи, когда файл не должен быть само-содержащим, а должен быть включен текстом в определенной точке кода. Примерами являются файлы, которые должны быть включены несколько раз или расширения, специфичные для платформы, которые по сути являются частью других заголовков. Такие файлы должны использовать расширение файла .inc.
Если шаблон или встроенная функция объявлены в файле .h, определите их в этом же файле. Определения этих конструкций должны быть включены в каждый файл .c, который их использует, иначе программа может не собираться в некоторых конфигурациях сборки.

## Защита с помощью #define | The #define Guard
Все файлы заголовков должны иметь защиту от множественного включения с помощью #define guards. Формат имени символа должен быть {}<FILE>{}_H.
Чтобы гарантировать уникальность, они должны основываться на полном пути в дереве исходного кода проекта. Например, файл foo/src/bar/baz.h в проекте foo должен иметь следующий гвард:
```c
#ifndef __BAZ_H
#define __BAZ_H
...
#endif // __BAZ_H
```
# Предварительное декларирование | Forward Declarations
Следует использовать #include для включения файлов с объявлениями функций, а не пытаться избежать включения, копируя переднее объявление.

## Определение
"Предварительное декларирование" - это объявление класса, функции или шаблона без соответствующего определения. При использовании функции, объявленной в заголовочном файле, всегда включайте этот заголовок с помощью #include.

## Преимущества
Избегает конфликтов при рефакторинге кода или изменении прототипов.
Может быть сложно определить, нужно ли использовать переднее объявление или полное #include для конкретного участка кода, особенно при использовании неявных операций преобразования. В крайних случаях замена #include передним объявлением может незаметно изменить значение кода.

## Недостатки
Ненужные #include заставляют компилятор открывать больше файлов и обрабатывать больше входных данных.
Они также могут заставить ваш код перекомпилироваться чаще из-за изменений в заголовке.
Пожалуйста, обратитесь к разделу Имена и Порядок Включений для правил, когда нужно использовать #include заголовка.

# Встроенные функции | Inline Functions
Определяйте функции встроенными только тогда, когда они малы, скажем, менее 10 строк.

## Определение
Вы можете объявить функции таким образом, чтобы компилятор мог встраивать их встроенно, а не вызывать через обычный механизм вызова функций.

## Преимущества
Встраивание функции может генерировать более эффективный объектный код, если встраиваемая функция небольшая. Не стесняйтесь встраивать методы доступа и мутаторы, а также другие короткие функции, критические для производительности.

## Недостатки
Чрезмерное использование встраивания на самом деле может замедлить программы. В зависимости от размера функции встраивание её может увеличить или уменьшить размер кода. Встраивание очень маленькой функции-аксессора обычно уменьшит размер кода, в то время как встраивание очень большой функции может значительно увеличить его. На современных процессорах меньший код обычно работает быстрее благодаря лучшему использованию кэша инструкций.

## Решение
Хорошее правило - не встраивать функцию, если она более 10 строк.
Еще одно полезное правило: обычно не стоит встраивать функции с циклами или операторами switch (за исключением случаев, когда цикл или оператор switch никогда не выполняется). Важно знать, что функции не всегда встраиваются, даже если они объявлены как таковые; например, виртуальные и рекурсивные функции обычно не встраиваются. Обычно рекурсивные функции не должны быть встраиваемыми.

# Порядок параметров в функциях | Function Parameter Ordering
При определении функции порядок параметров: сначала входные, затем выходные.
Параметры функций на C/C++ могут быть входными для функции, выходными из функции или и входными, и выходными одновременно. Входные параметры обычно являются значениями или константными ссылками, а выходные и входно-выходные параметры будут неконстантными указателями. При упорядочивании параметров функции поместите все параметры только для ввода перед любыми параметрами для вывода. В частности, не добавляйте новые параметры в конец функции только потому, что они новые; разместите новые параметры только для ввода перед параметрами для вывода.
Это не жесткое правило. Параметры, которые одновременно и входные, и выходные (часто классы/структуры), могут запутать ситуацию, и, как всегда, согласованность с родственными функциями может потребовать соглашения отступать от правила.

# Имена и порядок включений | Names and Order of Includes
Используйте стандартный порядок для читаемости и избегания скрытых зависимостей: Связанный заголовок, библиотека C, библиотека C++, заголовки других библиотек, заголовки вашего проекта.
Все заголовочные файлы проекта должны быть перечислены как потомки исходного каталога проекта без использования UNIX-сокращений каталогов . (текущий каталог) или .. (родительский каталог). Например, для включения заголовка awesome-project/src/base/logging.h используйте:
```c
#include "base/logging.h"
```
В файлах dir/foo.c или dir/foo_test.c, цель которых в основном состоит в реализации или тестировании функционала из dir2/foo2.h, упорядочивайте включения следующим образом:

1. dir2/foo2.h.
1. Системные файлы на C.
1. .h файлы других библиотек.
1. .h файлы вашего проекта.
   
С предпочтительным порядком, если dir2/foo2.h пропускает какие-либо необходимые включения, сборка dir/foo.c или dir/foo_test.c сломается. Таким образом, это правило гарантирует, что проблемы сборки будут обнаружены сначала для людей, работающих над этими файлами, а не для невинных людей в других пакетах.
dir/foo.c и dir2/foo2.h обычно находятся в одном каталоге (например, base/basictypes_test.c и base/basictypes.h), но иногда могут находиться в разных каталогах. Внутри каждого раздела включения должны быть упорядочены в алфавитном порядке. Обратите внимание, что старый код может не соответствовать этому правилу и должен быть исправлен при удобном случае.
Включайте все заголовки, которые определяют символы, от которых вы зависите (за исключением случаев обратного объявления). Если вы полагаетесь на символы из bar.h, не полагайтесь на то, что вы включили foo.h, который (в данный момент) включает bar.h: включите bar.h самостоятельно, если foo.h явно не демонстрирует свое намерение предоставить вам символы из bar.h. Однако любые включения, присутствующие в связанном заголовке, не нужно включать снова в связанный cc (т.е. foo.c может полагаться на включения foo.h).
Например, включения в awesome-project/src/foo/internal/fooserver.c могут выглядеть так:

```c
#include "foo/server/fooserver.h" 
#include <sys/types.h>
#include <unistd.h> 
 
#include "base/basictypes.h"
#include "base/commandlineflags.h"
#include "foo/server/bar.h"
```
Этот порядок обеспечивает читаемость, избегает скрытых зависимостей и помогает обнаруживать проблемы сборки на ранних стадиях разработки.

# Область видимости | Scoping
## Локальные переменные | Local Variables

Объявляйте переменные функции в области видимости функции и инициализируйте переменные в объявлении.
В частности, инициализация должна использоваться вместо объявления и присваивания, например:
```c
int i;
i = MAGIC_CONSTANT;     // Плохо – инициализация отдельно от объявления.
int j = 0;              // Хорошо – объявление с инициализацией.
char *v = NULL;         // Хорошо – v начинает инициализированным.
```

## Статические и глобальные переменные | Static and Global Variables
Избегайте глобальных переменных всякий раз, когда это возможно. Если глобальные переменные необходимы, предпочтение отдавайте единой структуре с несколькими членами вместо множества отдельных переменных.
Обеспечьте ясную, единую точку инициализации и уничтожения.
Не полагайтесь на завершение программы для неявного освобождения памяти или иным образом очистки после глобальных или статических переменных.

# Разное | Miscellaneous

## Целочисленные типы | Integer Types

При объявлении переменной используйте тип с точной размерностью (например, int16_t). Если ваша переменная представляет собой значение, которое когда-либо может быть больше или равно 2^31 (2 ГиБ), используйте 64-битный тип, такой как int64_t. Имейте в виду, что даже если ваше значение никогда не будет слишком большим для int, оно может использоваться в промежуточных вычислениях, которые могут потребовать более широкого типа. В случае сомнений выбирайте более широкий тип.

### Определение
Си не указывает размеры своих целочисленных типов. Обычно люди предполагают, что short имеет 16 бит, int - 32 бит, long - 32 бита, а long long - 64 бита.

### Преимущества
Единообразие объявления.
Ясность намерений и ожидаемого размера данных.

### Недостатки
Размеры целочисленных типов в Си могут меняться в зависимости от компилятора и архитектуры.

### Решение
<stdint.h> определяет типы, такие как int16_t, uint32_t, int64_t и т. д. Вам следует всегда использовать их вместо short, unsigned long long и подобных, когда вам нужна гарантия на размер целого числа. Из типов целых чисел Си следует использовать только int. При необходимости вы можете использовать стандартные типы, такие как size_t и ptrdiff_t. Если ваша платформа определяет беззнаковые типы с префиксом "u_", создайте typedef для каждого типа с просто "u" (без подчеркивания).
Мы часто используем int для целых чисел, о которых мы знаем, что они не будут слишком большими, например, для счетчиков циклов. Вы можете использовать обычный int для таких вещей. Предполагайте, что int имеет как минимум 32 бита, но не предполагайте, что у него больше 32 бит. Если вам нужен 64-битный тип целого числа, используйте int64_t или uint64_t.
Для целых чисел, о которых мы знаем, что они могут быть "большими", используйте int64_t.
Вы должны использовать беззнаковые целочисленные типы, такие как uint32_t, когда значение не должно быть отрицательным.
Если ваш код представляет собой контейнер, который возвращает размер, убедитесь, что используете тип, который может вместить любое возможное использование вашего контейнера. В случае сомнений используйте более крупный тип, а не более маленький.
Будьте осторожны при преобразовании типов целых чисел. Преобразования и повышения целых чисел могут вызывать неочевидное поведение.

## 64-битная переносимость | 64-bit Portability
Код должен быть дружественным к 64-битным и 32-битным системам. Учитывайте проблемы вывода на печать, сравнений и выравнивания структур.
Спецификаторы printf() для некоторых типов не являются чисто переносимыми между 32-битными и 64-битными системами. C99 определяет некоторые переносимые форматные спецификаторы. К сожалению, MSVC 7.1 не понимает некоторые из этих спецификаторов, а стандарт пропускает несколько.
Помните, что 
```c
sizeof(void *) != sizeof(int).
```
Используйте суффиксы LL или ULL при необходимости для создания 64-битных констант.
Если вам действительно нужен разный код на 32-битных и 64-битных системах, используйте #ifdef _LP64 для выбора между вариантами кода. (Но, пожалуйста, избегайте этого, если это возможно, и держите любые такие изменения локализованными.)

## Препроцессорные макросы | Preprocessor Macros
Будьте очень осторожны с макросами. Предпочтительнее использовать встраиваемые функции, перечисления и константные переменные вместо макросов.
Макросы означают, что код, который вы видите, не совпадает с кодом, который видит компилятор. Это может привести к неожиданному поведению, особенно учитывая, что макросы имеют глобальную область видимости.
Вместо использования макроса для встраивания критического с точки зрения производительности кода используйте встраиваемую функцию. Не используйте макрос для "сокращения" длинного имени переменной. Вместо использования макроса для условной компиляции кода... ну, вообще лучше этого не делать (за исключением, конечно, макросов #define для предотвращения двойного включения файлов заголовков). Это сильно затрудняет тестирование.
Макросы могут делать вещи, которые невозможно сделать с помощью других техник, и вы действительно видите их в кодовой базе, особенно в более низкоуровневых библиотеках. И некоторые из их особых возможностей (такие как строковые литералы, конкатенация и т. д.) недоступны через сам язык. Но перед использованием макроса тщательно обдумайте, есть ли способ добиться того же результата без макроса.
Следующий шаблон использования позволит избежать многих проблем с макросами; если вы используете макросы, следуйте этому шаблону, насколько это возможно:
Будьте осторожны при определении макросов в файле .h.
#define макросы в более локальной области видимости, когда это возможно. Для сильно локализованных макросов #undef их сразу после использования.
Не просто #undef существующий макрос перед заменой его своим; вместо этого выбирайте имя, которое, вероятно, будет уникальным.
Избегайте использования ## для генерации имён функций/членов/переменных.

## 0 и NULL
Используйте 0 для целых чисел, 0.0 для вещественных чисел, NULL для указателей и '\0' для символов.
## sizeof
Предпочтительнее использовать sizeof(varname) вместо sizeof(type).
Используйте sizeof(varname), когда вам нужно узнать размер конкретной переменной. sizeof(varname) будет корректно обновляться, если кто-то изменит тип переменной сейчас или позже. Вы можете использовать sizeof(type) для кода, не связанного с какой-либо конкретной переменной, например, для кода, управляющего внешним или внутренним форматом данных, где использование переменной соответствующего типа неудобно.

# Именование | Naming
Самые важные правила согласованности относятся к именованию. Стиль имени немедленно информирует нас о том, что это за сущность: тип, переменная, функция, константа, макрос и т. д., без необходимости искать объявление этой сущности. Наш мозг очень полагается на эти правила именования для анализа и понимания кода.
Правила именования весьма произвольны, но мы считаем, что согласованность важнее индивидуальных предпочтений в этой области, поэтому независимо от того, находите ли вы их разумными или нет, правила - это правила.

## Общие правила именования
Имена функций, переменных и файлов должны быть описательными; избегайте сокращений.
Давайте имена, которые максимально описывают сущность, но не переборщите. Не стоит беспокоиться о сохранении горизонтального пространства, потому что намного важнее сделать ваш код немедленно понятным для нового читателя. Не используйте сокращения, которые могут быть неоднозначны или незнакомы читателям вне вашего проекта, и не сокращайте слова путем удаления букв внутри слова. Исключением из этого правила являются переменные итераторов циклов. В этих случаях i, iter и подобные имена принимаются.
```c
int price_count_reader; // Без сокращений.
int num_errors; // "num" - широко распространенная конвенция.
int num_dns_connections; // Большинство людей знают, что означает "DNS".
int n; // Не имеет смысла.
int nerr; // Неоднозначное сокращение.
int n_comp_conns; // Неоднозначное сокращение.
int wgc_connections; // Только вы знаете, что означает это сокращение.
int pc_reader; // Многое может быть сокращено как "pc".
int cstmr_id; // Удаляет внутренние буквы.
```
## Имена файлов | File Names
Имена файлов должны быть написаны строчными буквами с разделением слов знаком подчеркивания (_). Следуйте соглашению, принятому в вашем проекте.
Файлы на языке C должны оканчиваться на .c, а заголовочные файлы - на .h. Файлы, которые должны быть включены в тексте в определенных местах, должны оканчиваться на .inc (см. также раздел о самостоятельных заголовках).
Не используйте имена файлов, которые уже существуют в /usr/include, такие как db.h.
В общем случае делайте ваши имена файлов очень специфичными. Например, используйте http_server_logs.h вместо logs.h. Очень распространенным случаем является наличие пары файлов, например, foo_bar.h и foo_bar.c, определяющих класс с именем FooBar.
Встраиваемые функции должны находиться в файле с расширением .h. Если ваши встраиваемые функции очень короткие, их следует помещать непосредственно в ваш файл .h.

## Имена типов | Type Names
Имена типов должны быть написаны строчными буквами и заканчиваться суффиксом "_t". Структуры должны включать typedef для устранения необходимости использования ключевого слова struct во всем коде. Этот typedef обычно выполняется в рамках определения структуры, например:
```c
typedef struct _foo {
    char *name;
} foo_t;
```
## Имена переменных | Variable Names
Имена переменных и членов данных должны быть написаны строчными буквами с подчеркиваниями между словами. Например: a_local_variable, a_struct_data_member.
Для переменных типа указателей следует добавлять префикс "p_". Кроме того, используйте "pp_" для типов указателей на указатели. Если вам нужно три уровня косвенности, рассмотрите перестройку вашего кода.
Для переменных с неоднозначным типом единицы измерения (например, время, расстояние) включайте единицу измерения как последнее слово в имени переменной, например:
```c
uint32_t delay_seconds; // ОК - Включает единицу измерения
size_t *p_length; // ОК - Использует p_ для типа указателя
uint32_t distance; // Плохо - Нет единицы измерения. Это метры, футы или фурлонги?
```
## Общие имена переменных
Например:
```c
char *table_name; // ОК - использует подчеркивание.
char *tablename; // ОК - все строчные буквы.
char *tableName; // Плохо - смешанный регистр.
```
## Поля структур | Struct Data Members
Поля данных структур, как статические, так и нестатические, именуются как обычные переменные, не являющиеся полями. Избегайте повторения типа данных в именах членов структур.
```c
typedef struct _table {
    size_t row_length; // ОК - использует подчеркивание, все строчные буквы
    char *table_name; // Плохо - повторяет тип данных в имени члена
} table_t;
```
## Глобальные переменные | Global Variables
Глобальные переменные должны быть исключительно редкими, но если вы их используете, добавьте префикс g_ для удобства отличия от локальных переменных.

## Именованные константы | Constant Names
Константы, определённые с помощью макросов препроцессора, должны быть написаны ЗАГЛАВНЫМИ БУКВАМИ, разделяя слова подчёркиваниями. Кроме того, рассмотрите возможность добавления префикса имени определённых значений с подсистемой или модулем, для которых константа имеет отношение, например:
```c
#define FOO_MAX_VALUE 32
```

## Имена функций | Function Names
Функции следуют правилам, аналогичным именам переменных. Они все в нижнем регистре и разделены подчеркиваниями. При определении нестатических, неутилитарных функций включите подсистему или модуль в качестве префикса к имени функции, чтобы избежать конфликтов с общими именами функций, например:
```c
int foo_measure_string(char *);
```
## Имена перечислений | Enumeration Names

Типы перечислений должны следовать общим правилам для типов. Имена типов в нижнем регистре, разделены подчеркиваниями. Они также должны включать typedef внутри. Значения внутри перечисления должны быть именованы в соответствии с правилами для макросов: все заглавные буквы и разделены подчеркиваниями.
```c
typedef enum _foo_error {
    OK = 0,
    OUT_OF_MEMORY = 1,
    MALFORMED_INPUT = 2,
} foo_error_t;
```
## Имена макросов | Macro Names
Макросы должны называться заглавными буквами и разделены подчеркиваниями, например:
```c
#define ROUND ...
#define PI_ROUNDED 3.0
```
# Комментарии | Comments
Хотя их писать довольно неприятно, комментарии абсолютно необходимы для того, чтобы наш код был читаемым. Следующие правила описывают, что и где нужно комментировать. Но помните: хотя комментарии очень важны, лучший код самодокументирующийся. Давайте разумные имена типам и переменным, это гораздо лучше, чем использование непонятных имен, которые затем нужно объяснять через комментарии.
При написании комментариев ориентируйтесь на свою аудиторию: следующего участника, который будет разбираться в вашем коде. Будьте щедры — следующим может бытье вы!

## Стиль комментариев | Comment Style
Используйте либо синтаксис //, либо /\* \*/, главное, чтобы вы были последовательны.
Вы можете использовать как //, так и /\* \*/, однако, // гораздо более распространен. Будьте последовательны в том, как вы комментируете и какой стиль вы используете.

## Комментарии к файлам | File Comments
Каждый файл должен иметь комментарий в начале, описывающий его содержимое.
Обычно файл .h описывает классы, объявленные в файле, с обзором их назначения и использования. Файл .c должен содержать больше информации о деталях реализации или обсуждении сложных алгоритмов. Если вы считаете, что информация о деталях реализации или обсуждении алгоритмов будет полезна для того, кто читает .h, не стесняйтесь поместить это туда, но укажите в .c, что документация находится в файле .h.
Не дублируйте комментарии как в .h, так и в .c. Дублирующие комментарии могут расходиться.

## Комментарии к функциям | Function Comments
- комментарии к объявлению описывают использование функции
- комментарии к определению функции описывают ее работу

### Объявление функции | Function Declaration
Каждое объявление функции должно иметь комментарии непосредственно перед ним, описывающие, что делает функция и как ее использовать. Эти комментарии должны быть описательными ("Открывает файл") вместо императивных ("Откройте файл"); комментарий описывает функцию, а не указывает ей, что делать. В общем, эти комментарии не описывают, как функция выполняет свою задачу. Это должно оставаться на комментарии в определении функции.
Типы вещей, которые следует упоминать в комментариях к объявлению функции:
- Что является входными и выходными данными.
- Если функция выделяет память, которую вызывающий должен освободить.
- Может ли какой-либо из аргументов быть нулевым указателем.
- Есть ли какие-либо последствия для производительности того, как используется функция.
- Является ли функция повторно входящей. Каковы ее предположения синхронизации?
Не будьте излишне многословными или указывайте на полностью очевидные вещи.

### Определения функций | Function Definitions
Если есть что-то сложное в том, как функция выполняет свою работу, в определении функции должен быть пояснительный комментарий. Например, в комментарии к определению вы можете описать любые хитрости в коде, дать обзор шагов, которые вы проходите, или объяснить, почему вы выбрали реализацию функции таким образом, а не использование жизнеспособной альтернативы. Например, вы можете упомянуть, почему ей необходимо получить блокировку на первой половине функции, но почему это не нужно для второй половины.
Обратите внимание, что вы не должны просто повторять комментарии, данн ами с объявлением функции, в файле .h или где-либо еще. Можно кратко резюмировать, что делает функция, но акцент в комментариях должен быть на том, как она это делает.

## Комментарии к переменным | Variable Comments
В общем случае фактическое имя переменной должно быть достаточно описательным, чтобы дать хорошее представление о том, для чего переменная используется. В некоторых случаях требуются дополнительные комментарии.

### Члены структуры | Struct Members
Каждый член должен иметь комментарий, описывающий, для чего он используется. Если переменная может принимать специальные значения с особым смыслом, такие как нулевой указатель или -1, документируйте это.

### Глобальные переменные | Global Variables
Как и с данными членами, все глобальные переменные должны иметь комментарий, описывающий, что они и для чего они используются.

## Комментарии к реализации | Implementation Comments
В вашей реализации должны быть комментарии в сложных, неочевидных, интересных или важных частях вашего кода.

### Пояснительные комментарии | Explanatory Comments
Сложные или сложные блоки кода должны иметь комментарии перед ними.
```c
// Деление результата на два, учитывая, что x
// содержит перенос от сложения.
for (int i = 0; i < result->size(); i++) {
    x = (x << 8) + (*result)[i];
    (*result)[i] = x >> 1;
    x &= 1;
}
```
### Построчные комментарии | Line Comments
Также строки, которые неочевидны, должны получить комментарий в конце строки. Эти комментарии в конце строки должны быть отделены от кода как минимум на 1 пробел. Пример:
```c
// Если у нас достаточно памяти, mmap также данных части.
mmap_budget = MAX(0, mmap_budget - index->length);
if (mmap_budget >= data_size && !mmap_data(mmap_chunk_bytes, mlock))
    return; // Ошибка уже зарегистрирована.
```
Если у вас несколько комментариев на последовательных строках, часто более читаемо выстраивать их в один ряд.

### Параметры функций | Function Parameters
Когда вы передаете нулевой указатель или литеральные целочисленные значения в функции, рассмотрите возможность добавления комментария о том, что они представляют собой, или сделайте свой код самодокументирующимся, используя константы. Например, сравните:
```c
uint32_t status = calculate_something(interesting_value,
                                                       10,
                                                       0,
                                                       NULL); // Что это за аргументы??
```
по сравнению с:
```c
uint32_t status = calculate_something(interesting_value,
                                                    10, // Значение по умолчанию для базы.
                                                    0, // Это не первый раз, когда мы вызываем это.
                                                    NULL); // Нет обратного вызова.
```
Обратите внимание, что вы никогда не должны описывать сам код. Предполагайте, что человек, читающий код, знает C лучше вас, даже если он или она не знает, что вы пытаетесь сделать:
```c
// Теперь переходим к массиву b и убеждаемся, что если есть i,
// следующий элемент будет i+1.
... // Ну что за бесполезный комментарий.
```
# Пунктуация, орфография и грамматика | Punctuation, Spelling and Grammar
Обратите внимание на пунктуацию, орфографию и грамматику; легче читать хорошо написанные комментарии, чем плохо написанные.
Комментарии должны быть так же читаемыми, как и повествовательный текст, с правильным использованием заглавных букв и знаков препинания. Во многих случаях полные предложения более читабельны, чем фрагменты предложений. Короткие комментарии, такие как комментарии в конце строки кода, иногда могут быть менее формальными, но вы должны быть последовательны в своем стиле.
Хотя может быть раздражающе, когда рецензент кода указывает, что вы используете запятую, когда следует использовать точку с запятой, очень важно, чтобы исходный код сохранял высокий уровень ясности и читабельности. Правильная пунктуация, орфография и грамматика помогают достигнуть этой цели.

# Комментарии TODO | TODO Comments
Используйте комментарии TODO для временного кода, краткосрочного решения или достаточно хорошего, но не идеального кода.
TODO должны включать строку TODO заглавными буквами. Основная цель - иметь последовательный TODO, который можно искать, чтобы узнать, как получить дополнительные детали по запросу. Если код рецензируется с пометкой TODO, ожидайте объяснения, почему она все еще присутствует. Наиболее часто это используется для обозначения места, где будет добавлено нечто вне рамок проекта или улучшение.
Если ваше TODO имеет форму "В будущем сделайте что-то", это, вероятно, должно быть в тикете.

# Форматирование | Formatting
Стиль кодирования и форматирование довольно произвольны, но проект намного легче следить, если все используют один и тот же стиль. Люди могут не соглашаться со всеми аспектами правил форматирования, и некоторые из правил могут потребовать некоторого времени для привыкания, но важно, чтобы все участники проекта следовали правилам стиля, чтобы они могли легко читать и понимать код всех.

## Длина строки | Line Length
Каждая строка текста в вашем коде должна быть не более 100 символов в длину.

### Исключения
Если строка комментария содержит пример команды или литеральный URL длиннее 100 символов, эта строка может быть длиннее 100 символов для удобства копирования и вставки.
Сырые строковые литералы могут содержать контент, превышающий 100 символов. За исключением тестового кода, такие литералы должны появляться ближе к верху файла.
Строка #include с длинным путем может превышать 100 символов в столбцах.

## Окончания строк | Line Endings
Используйте окончания строк в стиле Unix. Windows поддерживает этот подход, в то время как Linux-системы менее толерантны к нему. Вы должны настроить свой редактор для сохранения файлов с окончаниями строк в стиле Unix.

## Пробелы против табуляции | Spaces vs. Tabs
Используйте только пробелы и делайте отступы по 4 пробелам.
Мы используем пробелы для отступов. Не используйте табуляцию в своем коде. Вы должны настроить свой редактор так, чтобы при нажатии клавиши табуляции он вставлял пробелы.

## Объявление и определение функций | Function Declarations and Definitions
Тип возвращаемого значения на предыдущей строке перед именем функции, параметры на той же строке, если они помещаются. Размещение имени функции на краю делает поиск ее определения в незнакомом кодовой базе намного проще. Оборачивайте списки параметров, которые не помещаются в одну строку, как вы бы оборачивали аргументы в вызове функции.
```c
uint32_t
function_name(char *name) {
...
}

Если у вас слишком много текста для помещения на одной строке:

uint32_t
really_long_function_name(char *name,
size_t length,
uint32_t value) {
...
}
```
Некоторые моменты, на которые следует обратить внимание:

- Открывающая скобка всегда на той же строке, что и имя функции.
- Никогда нет пробела между именем функции и открывающей скобкой.
- Никогда нет пробела между скобками и параметрами.
- Открывающая фигурная скобка всегда в конце той же строки, что и последний параметр.
- Закрывающая фигурная скобка либо на последней строке отдельно, либо (если другие правила стиля позволяют) на той же строке, что и открывающая фигурная скобка.
- Между закрывающей скобкой и открывающей фигурной скобкой должен быть пробел.
- Все параметры должны иметь имена, с одинаковыми именами в объявлении и определении.
- Все параметры должны быть выровнены, если это возможно.
- Если некоторые параметры не используются, закомментируйте имя переменной в определении функции или используйте макрос UNUSED_PARAMETER.

## Вызовы функций | Function Calls
Возможны три варианта записи вызова функции: все на одной строке, аргументы разбиваются по скобкам или начинаются на новой строке с отступом в четыре пробела и продолжаются с этим отступом. По умолчанию используйте минимальное количество строк, включая помещение нескольких аргументов на одной строке, если это уместно.
Вызовы функций имеют следующий формат:
```c
uint32_t status = do_something(argument1, argument2, argument3);
```
Если аргументы не помещаются на одной строке, их следует разбить на несколько строк, причем каждая последующая строка должна быть выровнена с первым аргументом. Если вы разбиваете какие-либо аргументы, разбейте все аргументы, по одному аргументу на строку. Не добавляйте пробелы после открывающей скобки или перед закрывающей скобкой:
```c
uint32_t status = do_something(averyveryveryverylongargument1,
                                                           argument2,
                                                           argument3);
```
Аргументы могут быть размещены на последующих строках с отступом в четыре пробела:
```c
if (...) {
    ...
    ...
    if (...) {
        DoSomething(
            argument1, // отступ в 4 пробела
            argument2,
            argument3,
            argument4);
    }
}
``
Иногда аргументы формируют структуру, которая важна для читаемости. В таких случаях вы можете отформатировать аргументы в соответствии с этой структурой:
// Преобразование виджета с помощью матрицы 3x3.
```c
widget_transform(x1, x2, x3,
                 y1, y2, y3,
                 z1, z2, z3);
```
## Условные операторы | Conditionals
Предпочтительно не использовать пробелы внутри скобок. Ключевые слова if и else должны находиться на отдельных строках.
Вставьте пробел между if и открывающей скобкой. Не добавляйте пробелы между условным оператором и скобками.
```c
if (condition) { // нет пробелов внутри скобок
    ... // отступ в 4 пробела.
} else if (...) { // else находится на той же строке, что и закрывающая скобка.
    ...
} else {
    ...
}
````
Операторы if всегда должны включать фигурные скобки, даже если в условии есть только одно выражение.
## Циклы и операторы switch | Loops and Switch Statements
Аннотируйте не тривиальные переходы между case.
Фигурные скобки должны быть включены в циклы, даже для циклов с одним оператором. Пустые тела циклов должны использовать {} или continue, но не одиночную точку с запятой.
```c
switch (var) {
case 0: // 0 пробелов в отступе
    ... // отступ в 4 пробела
    break;
case 1:
    ...
    break;
default:
    assert(0);
}
```
## Выражения с указателями и ссылками | Pointer and Reference Expressions
Пробелы не должны окружать точку или стрелку. Операторы указателей не должны иметь пробелов после * или &.
Ниже приведены примеры правильно отформатированных выражений с указателями и ссылками:
```c
x = *p;
p = &x;
x = r.y;
x = r->y;
```
Обратите внимание, что:
- Нет пробелов вокруг точки или стрелки при доступе к члену.
- Операторы указателей не имеют пробела после * или &.
- При объявлении указателя переменной или аргумента вы должны поместить звездочку рядом с именем переменной:
```c
char *c;
```
##Логические выражения | Boolean Expressions
Когда у вас есть логическое выражение, длина которого превышает стандартную длину строки, следует соблюдать однородность в разбиении строк.
В этом примере логический оператор И всегда находится в конце строк:
```c
    if (this_one_thing > this_other_thing &&
    a_third_thing == a_fourth_thing &&
    yet_another && last_one) {
    ...
}
```
Обратите внимание, что при разбиении кода в этом примере оба оператора && логического И находятся в конце строки. Разрешено также разбивать все операторы в начале строки. С умом используйте дополнительные скобки, потому что они могут значительно повысить читаемость, когда используются правильно.

## Возвращаемые значения | Return Values
Не нужно лишний раз обрамлять выражение return скобками.
Используйте скобки в выражении return expr; только там, где бы вы их использовали в x = expr;.
Предпочтительно выполнить любую операцию перед самим return. Это помогает при отладке за счет возможного добавления дополнительной локальной переменной.
```c
return result; // В простом случае не используйте скобки.
// Скобки можно использовать, чтобы сделать сложное выражение более читаемым.
return (some_long_condition &&
another_condition);
```
```c
return (value); // Вы не напишете var = (value);
return(result); // return не является функцией!
```
## Директивы препроцессора | Preprocessor Directives
Знак решетки, который начинает директиву препроцессора, всегда должен находиться в начале строки.
Даже когда директивы препроцессора находятся в теле отступленного кода, директивы должны начинаться с начала строки.
По желанию можно включить комментарий в конце строки после endif, отмечающий условие #if.
```c
// Хорошо - директивы в начале строки
    if (lopsided_score) {
#if DISASTER_PENDING // Правильно – Начинается с начала строки
        drop_everything();
#    if NOTIFY // OK – Пробелы после
        notify_client();
#    endif
#endif // DISASTER_PENDING
     back_to_normal();
}
// Плохо - смещенные директивы
if (lopsided_score) {
    #if DISASTER_PENDING // Неправильно! "#if" должно быть в начале строки
    DropEverything();
    #endif // Неправильно! Не делайте отступ "#endif"
    BackToNormal();
}
```
## Горизонтальные пробелы | Horizontal Whitespace
Использование горизонтальных пробелов зависит от места. Никогда не оставляйте после строки конечные пробелы.

### Циклы и условные операторы | Loops and Conditionals
```c
if (b) {               // Пробел после ключевого слова в условиях и циклах.
} else {               // Пробелы вокруг else.
}

while (test) {}        // Обычно нет пробелов внутри скобок.

// Для циклов for всегда есть пробел после точки с запятой.
for (i = 0; i < 5; ++i) {
for ( ; i < 5; ++i) {
    ...

switch {
case 1:                 // Нет пробела перед двоеточием в switch case.
    ...
case 2: break;          // Используйте пробел после двоеточия, если за ним следует код.
```
### Операторы | Operators
```c
// Операторы присваивания всегда имеют пробелы вокруг них.
x = 0;
// Другие двоичные операторы так же имеют пробелы вокруг них.
// Скобки не должны иметь внутреннего отступа.
v = w * x + y / z;
v = w * (x + z);

// Нет пробелов между унарными операторами и их аргументами.
x = -5;
++x;
if (x && !y)
...
```
### Приведения типов | Casts
```c
// Нет пробелов внутри скобок.
y = (char *)x;
// Опциональный пробел после скобок, но перед значением.
y = (char *) x;
```
## Вертикальные пробелы | Vertical Whitespace
Минимизируйте использование вертикальных пробелов.
Это скорее принцип, чем правило: не используйте пустые строки, когда это необходимо. В частности, не ставьте больше одной или двух пустых строк между функциями, избегайте начинать функции с пустой строки, не заканчивайте функции пустой строкой и будьте избирательны в использовании пустых строк внутри функций.
Основной принцип: чем больше кода помещается на один экран, тем легче следить и понимать поток управления программой. Конечно, читаемость может пострадать от слишком плотного или слишком растянутого кода, поэтому используйте свое усмотрение. Но в целом минимизируйте использование вертикальных пробелов.
Некоторые правила, которые могут помочь, когда пустые строки могут быть полезными:
- Пустые строки в начале или конце функции редко помогают читаемости.
- Пустые строки внутри цепочки блоков if-else могут хорошо помочь читаемости.
## Best Practices
### Возвращаемые значения | Return Values
Агрессивно проверяйте возвращаемое значение из всех функций с значимыми возвращаемыми значениями, особенно при выделении памяти. Проверяйте отсутствие ошибок и грациозно восстанавливайтесь или завершайте выполнение при их возникновении.
Рассмотрите возможность включения сообщения об ошибке в точке возвращения из функции при обнаружении ошибки. Это может служить также документацией и значительно помогает отслеживать цепочку ошибок, например:
```c
fp = fopen("/путь/к/файлу", "rb");
if (fp == NULL) {
    DBGERR("Не удалось открыть /путь/к/файлу для чтения: %d\n", errno);
    status = errno;
    goto ErrorExit;
}
...
ErrorExit:
return status;
```
Используйте номера ошибок платформы, когда они доступны. Определяйте значимые константы для ваших собственных кодов ошибок и убедитесь, что их значения не пересекаются с определениями платформы.
Когда ошибка вызывает возврат (а не повтор или другое восстановление), распространяйте исходный код ошибки настолько далеко, насколько это возможно.

### Обработка ошибок | Error Handling
Используйте единственную точку выхода из функций и используйте goto для достижения ее в случае ошибки. Исключение из этого правила - это ранняя проверка значений параметров, до любой локальной инициализации, которая может вернуть ошибку напрямую, например:
```c
int32_t
calculate_something(uint8_t *param_1, uint8_t *param_2) {
    int32_t status = S_OK;
    if (param_1 == NULL || param_2 == NULL) {
        return ERR_INVALID_PARAMETER;
    }
    ...
    return status;
}
```
Освобождайте ресурсы и проводите очистку в блоке выхода. Избегайте более одной метки goto в функции и не используйте goto для других потоков управления.
В начале функции инициализируйте переменные с помощью sentinel значений. Проверьте те же sentinel значения в блоках обработки ошибок, чтобы определить, необходима ли очистка, например:
```c
uint8_t *buf = NULL;
...
buf = malloc(100);
...
ErrorExit:
if (buf) {
    free(buf);
}
```
### Строки в программах | Strings in Programs
Большинство кода на C, написанного в ОEC, предназначено для развертывания в аустерных средах и подвержено обратному инжинирингу. Хотя значимые сообщения об ошибках могут значительно помочь отладке и определению корневой причины проблем, они не должны включаться в релизные сборки продуктов из-за размера и соображений "опсек".
Оберните процедуры отчета об ошибках в препроцессорные макросы, чтобы убедиться, что они заменяются пустым кодом в релизной сборке. Используйте эти макросы исключительно, чтобы избежать случайного включения лишних печатей или сообщений об ошибках.
Будьте осторожны при реализации макроса для удаления этих процедур. Рассмотрите следующее:
```c
#define DBGPRINT printf // Плохо - Все равно будет принимать любые аргументы!
#define DBGPRINT(fmt, ...) printf(fmt, ##VA_ARGS) // Хорошо - включает аргументы в определении макроса

DBGPRINT("function_name: %s: %d\n", error_message(), errno); // В первом случае это все равно включит строку "function_name" и вызов error_message()
```
# Следует обратить внимание на безопасность | Security Considerations
## Переполнение целых чисел | Integer Overflow
Переполнения целых чисел в C происходят из-за арифметических операций над значениями, результаты которых превышают доступное ограниченное хранилище в переменных. Когда используются переполненные значения (например, как указатели, смещения или размеры выделения), возникают проблемы безопасности (и, следовательно, также надежности).
Очень легко сделать ошибки в таких проверках, и проверки, которые зависят от машинно-специфического поведения переполнения, такого как wraparound (оборачивание), могут быть оптимизированы компилятором (см.: https://gcc.gnu.org/bugzilla/show_bug.cgi?id=30475). В этом разделе описаны некоторые шаблоны, которые могут быть использованы для создания безопасных и эффективных проверок.
При использовании современной версии GCC используйте встроенные функции проверки переполнения арифметики (перечисленные здесь: https://gcc.gnu.org/onlinedocs/gcc/Integer-Overflow-Builtins.html). Поскольку инструментарий, используемый в OEC, не всегда позволяет нам использовать самые последние и лучшие версии, мы должны знать, как выполнить эти проверки безопасно самостоятельно.

Сложение / Вычитание | Addition / Subtraction
Рассмотрим следующий код, который обрабатывает протокол длины-значения с длиной 4 байта, за которой следует содержимое:
```c
int32_t
process_buffer(uint8_t *buffer, size_t buffer_size) {
	int32_t rc = 0;
	size_t offset = 0;
	uint32_t item_len = 0;
  
	while (offset < buffer_size) {
		// Убедимся, что есть достаточно места для чтения длины следующего элемента
 		// Если количество, которое мы хотим получить (sizeof(uint32_t)), превышает оставшееся количество (size - offset), то возникает ошибка
		if (sizeof(uint32_t) > buffer_size - offset) {
 			rc = ERR_INSUFFICIENT_DATA;
 			goto ErrorExit; 
 		}
  
		// Извлекаем 4-байтовую длину из буфера
		item_len = *((uint32_t *) (buffer + offset));
  
		// Убедимся, что есть достаточно места для чтения указанного количества
		// Обязательно включите 4-байтовое поле длины в расчет места
		if (item_len > buffer_size - offset - sizeof(uint32_t)) {
			rc = ERR_INSUFFICIENT_DATA;
 			goto ErrorExit; 
		}
  
		rc = process_some_data(buffer + offset + sizeof(uint32_t),
						   buffer_size - offset - sizeof(uint32_t));
 		// ...
  
 		offset += sizeof(uint32_t) + item_len;
 	}
  
ErrorExit:
	return rc;
}
```
Интуитивный метод проверки результата сложения небезопасен. В следующих примерах демонстрируются различные методы выполнения проверок на переполнение. Все примеры в этом блоке проверяют состояние ошибки.
```c
if (offset + item_len < offset) { 		// Плохо – Зависит от машинно-специфического поведения переполнения и может быть оптимизировано
if (offset + item_len > buffer_size) { 		// Плохо – offset + item_len может привести к переполнению и пройдет эту проверку
if (item_len > buffer_size - offset) { 		// Хорошо – Проверяем, превышает ли количество, которое мы хотим получить, фактическое оставшееся количество
if (buffer_size - offset < item_len) { 		// Хорошо – Проверяем, меньше ли оставшееся количество, чем желаемое количество
```
## Умножение | Multiplication
Единственный правильный способ проверить переполнение целого числа - разделить максимально допустимый результат на множитель и сравнить результат с множимым или наоборот. Если результат меньше множимого, произведение этих двух значений вызовет переполнение целого числа. Поскольку это довольно очевидно, вот пример:
```c
#define SIZE_MAX ((size_t)-1) // Важно, чтобы SIZE_MAX был максимально возможным хранимым значением

// В положительном случае
if (n > 0 && m > 0 && SIZE_MAX/n >= m) {
    size_t bytes = n * m;
    ... // выделение пространства для "bytes"
}

// Проверка на ошибочный случай
if (n == 0 || m == 0 || SIZE_MAX/n < m) {
    // Установка условия ошибки
}
```
А вот отрицательный пример:
```c
size_t bytes = n * m;
if (bytes < n || bytes < m) { // Плохо – Основано на машинозависимом поведении переполнения и может быть оптимизировано
    ... // выделение пространства для "bytes"
}
```
# Ассемблер | Assembly
## Включение ассемблера в проект на C | Including Assembly in a C Project
Не встраивайте код на ассемблере непосредственно в C. Лучше создать отдельный модуль с расширением .s, определить символы и подключить собранный объект.

## Лучшие практики | Best Practices
Стандарты качества для ассемблера следует применять так же, как и для C. Если каждый байт важен (и это может быть), продолжайте проверять возвращаемые значения, освобождать ресурсы и т. д.
Почти каждая строка в исходнике ассемблера должна содержать комментарий о намерении. Следуйте рекомендациям по комментариям. Описывайте смысл и мотивацию, а не механику, если вы используете нестандартный трюк или машинное поведение.
